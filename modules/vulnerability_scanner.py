"""
Enhanced Vulnerability Scanner Module

This module handles advanced vulnerability assessment, CVE scoring,
risk categorization, and compliance checking for the Network Mapper tool.
"""

import json
import re
import socket
import ssl
import subprocess
import threading
from datetime import datetime
from typing import Dict, List, Tuple, Optional
try:
    import requests
except ImportError:
    requests = None

class VulnerabilityScanner:
    """
    Enhanced vulnerability scanner with CVE database integration and risk assessment
    """
    
    def __init__(self):
        self.vulnerability_db = self._load_vulnerability_database()
        self.cve_database = {}
        self.service_vulnerabilities = {
            'ssh': {
                'weak_versions': ['OpenSSH_7.4', 'OpenSSH_6.6', 'OpenSSH_5.3'],
                'common_vulns': ['CVE-2016-0777', 'CVE-2016-0778', 'CVE-2018-15473']
            },
            'http': {
                'server_headers': ['Server', 'X-Powered-By', 'X-AspNet-Version'],
                'common_vulns': ['CVE-2021-44228', 'CVE-2017-5638', 'CVE-2014-6271']
            },
            'https': {
                'ssl_vulns': ['POODLE', 'BEAST', 'HEARTBLEED', 'FREAK'],
                'weak_ciphers': ['RC4', 'DES', '3DES', 'MD5']
            },
            'ftp': {
                'anonymous_login': True,
                'common_vulns': ['CVE-2010-4221', 'CVE-2011-2523']
            },
            'telnet': {
                'unencrypted': True,
                'common_vulns': ['CVE-2011-4862']
            },
            'smtp': {
                'open_relay': True,
                'common_vulns': ['CVE-2016-10009']
            },
            'snmp': {
                'default_communities': ['public', 'private'],
                'common_vulns': ['CVE-2017-6736']
            }
        }
    
    def _load_vulnerability_database(self):
        """Load vulnerability information for common services"""
        return {
            21: {
                "service": "FTP",
                "vulnerabilities": [
                    "Anonymous login may be enabled",
                    "Brute force attacks possible",
                    "Unencrypted data transmission",
                    "Directory traversal vulnerabilities"
                ],
                "attack_vectors": ["Brute force", "Anonymous access", "Man-in-the-middle"]
            },
            22: {
                "service": "SSH",
                "vulnerabilities": [
                    "Weak authentication methods",
                    "Brute force attacks possible",
                    "Outdated SSH versions may have CVEs"
                ],
                "attack_vectors": ["Brute force", "Key-based attacks", "Protocol downgrade"]
            },
            23: {
                "service": "Telnet",
                "vulnerabilities": [
                    "Unencrypted communication",
                    "Credentials sent in plaintext",
                    "No authentication encryption"
                ],
                "attack_vectors": ["Credential sniffing", "Man-in-the-middle", "Session hijacking"]
            },
            25: {
                "service": "SMTP",
                "vulnerabilities": [
                    "Open relay configuration",
                    "Email spoofing possible",
                    "User enumeration via VRFY/EXPN"
                ],
                "attack_vectors": ["Email spoofing", "Spam relay", "User enumeration"]
            },
            53: {
                "service": "DNS",
                "vulnerabilities": [
                    "DNS cache poisoning",
                    "Zone transfer attacks",
                    "DNS amplification attacks"
                ],
                "attack_vectors": ["Cache poisoning", "Zone transfer", "DDoS amplification"]
            },
            80: {
                "service": "HTTP",
                "vulnerabilities": [
                    "Unencrypted web traffic",
                    "Web application vulnerabilities",
                    "Information disclosure"
                ],
                "attack_vectors": ["Web app attacks", "Traffic interception", "XSS/SQLi"]
            },
            110: {
                "service": "POP3",
                "vulnerabilities": [
                    "Unencrypted email retrieval",
                    "Credentials sent in plaintext",
                    "Email content exposure"
                ],
                "attack_vectors": ["Credential sniffing", "Email interception", "Brute force"]
            },
            135: {
                "service": "RPC",
                "vulnerabilities": [
                    "RPC endpoint enumeration",
                    "Buffer overflow vulnerabilities",
                    "Privilege escalation possible"
                ],
                "attack_vectors": ["RPC enumeration", "Buffer overflow", "Privilege escalation"]
            },
            139: {
                "service": "NetBIOS",
                "vulnerabilities": [
                    "SMB relay attacks",
                    "Null session enumeration",
                    "Share enumeration"
                ],
                "attack_vectors": ["SMB relay", "Null sessions", "Share enumeration"]
            },
            143: {
                "service": "IMAP",
                "vulnerabilities": [
                    "Unencrypted email access",
                    "Credentials in plaintext",
                    "Email content exposure"
                ],
                "attack_vectors": ["Credential sniffing", "Email interception", "Brute force"]
            },
            443: {
                "service": "HTTPS",
                "vulnerabilities": [
                    "SSL/TLS configuration issues",
                    "Weak cipher suites",
                    "Certificate validation bypass"
                ],
                "attack_vectors": ["SSL/TLS attacks", "Certificate spoofing", "Weak encryption"]
            },
            445: {
                "service": "SMB",
                "vulnerabilities": [
                    "SMB relay attacks",
                    "EternalBlue (MS17-010)",
                    "Share enumeration and access"
                ],
                "attack_vectors": ["SMB relay", "EternalBlue exploit", "Share enumeration"]
            },
            993: {
                "service": "IMAPS",
                "vulnerabilities": [
                    "SSL/TLS configuration issues",
                    "Weak cipher suites",
                    "Certificate validation bypass"
                ],
                "attack_vectors": ["SSL/TLS attacks", "Certificate spoofing", "Brute force"]
            },
            995: {
                "service": "POP3S",
                "vulnerabilities": [
                    "SSL/TLS configuration issues",
                    "Weak cipher suites",
                    "Certificate validation bypass"
                ],
                "attack_vectors": ["SSL/TLS attacks", "Certificate spoofing", "Brute force"]
            },
            1433: {
                "service": "MSSQL",
                "vulnerabilities": [
                    "SQL injection vulnerabilities",
                    "Weak authentication",
                    "Database enumeration"
                ],
                "attack_vectors": ["SQL injection", "Brute force", "Database enumeration"]
            },
            1723: {
                "service": "PPTP",
                "vulnerabilities": [
                    "Weak encryption (MPPE)",
                    "Authentication bypass",
                    "VPN tunnel attacks"
                ],
                "attack_vectors": ["Encryption attacks", "Authentication bypass", "Tunnel hijacking"]
            },
            3306: {
                "service": "MySQL",
                "vulnerabilities": [
                    "SQL injection vulnerabilities",
                    "Weak root passwords",
                    "Database enumeration"
                ],
                "attack_vectors": ["SQL injection", "Brute force", "Database enumeration"]
            },
            3389: {
                "service": "RDP",
                "vulnerabilities": [
                    "BlueKeep (CVE-2019-0708)",
                    "Brute force attacks",
                    "Man-in-the-middle attacks"
                ],
                "attack_vectors": ["BlueKeep exploit", "Brute force", "Session hijacking"]
            },
            5432: {
                "service": "PostgreSQL",
                "vulnerabilities": [
                    "SQL injection vulnerabilities",
                    "Weak authentication",
                    "Database enumeration"
                ],
                "attack_vectors": ["SQL injection", "Brute force", "Database enumeration"]
            },
            5900: {
                "service": "VNC",
                "vulnerabilities": [
                    "Weak or no authentication",
                    "Unencrypted screen sharing",
                    "Remote access vulnerabilities"
                ],
                "attack_vectors": ["Unauthorized access", "Screen capture", "Remote control"]
            },
            6379: {
                "service": "Redis",
                "vulnerabilities": [
                    "No authentication by default",
                    "Command injection",
                    "Data exposure"
                ],
                "attack_vectors": ["Unauthorized access", "Command injection", "Data exfiltration"]
            },
            8080: {
                "service": "HTTP-Alt",
                "vulnerabilities": [
                    "Web application vulnerabilities",
                    "Administrative interfaces exposed",
                    "Unencrypted traffic"
                ],
                "attack_vectors": ["Web app attacks", "Admin panel access", "Traffic interception"]
            }
        }
    
    def assess_vulnerabilities(self, host, open_ports, services=None):
        """
        Assess vulnerabilities for a host based on open ports and services
        
        Args:
            host (str): Target host IP address
            open_ports (list): List of open ports
            services (dict): Dictionary of port -> service information
            
        Returns:
            dict: Vulnerability assessment results
        """
        if not open_ports:
            return {
                'vulnerabilities': [],
                'risk_level': 'Info',
                'summary': 'No open ports detected'
            }
        
        all_vulnerabilities = []
        
        for port in open_ports:
            service_data = services.get(port, {}) if services else {}
            
            # Extract service info string from the service data dictionary
            if isinstance(service_data, dict):
                service_info = service_data.get('raw_banner', '') or service_data.get('service', '')
            else:
                # Fallback for old string format
                service_info = str(service_data) if service_data else ""
            
            if port in self.vulnerability_db:
                vuln_data = self.vulnerability_db[port].copy()
                vuln_data["risk_level"] = self._calculate_risk_level(port, service_info)
                vuln_data['port'] = port
                vuln_data['service_info'] = service_info
                all_vulnerabilities.append(vuln_data)
        
        # Calculate overall risk level
        risk_level = self._calculate_overall_risk_level(all_vulnerabilities)
        
        # Generate summary
        summary = self._format_vulnerability_summary(all_vulnerabilities)
        
        return {
            'vulnerabilities': all_vulnerabilities,
            'risk_level': risk_level,
            'summary': summary,
            'host': host,
            'total_vulnerable_ports': len(all_vulnerabilities)
        }
    
    def _calculate_risk_level(self, port, service_info=""):
        """
        Calculate risk level based on port and service information
        
        Args:
            port (int): Port number
            service_info (str): Service information
            
        Returns:
            str: Risk level (High, Medium, Low)
        """
        # High-risk services
        high_risk_ports = [21, 23, 135, 139, 445, 3389, 5900, 6379]
        
        # Medium-risk services
        medium_risk_ports = [22, 25, 53, 110, 143, 993, 995, 1433, 1723, 3306, 5432]
        
        # Check for specific high-risk indicators in service info
        high_risk_indicators = [
            "anonymous", "default", "weak", "unencrypted", 
            "plaintext", "no auth", "open relay"
        ]
        
        service_lower = service_info.lower()
        
        if port in high_risk_ports:
            return "High"
        elif port in medium_risk_ports:
            return "Medium"
        elif any(indicator in service_lower for indicator in high_risk_indicators):
            return "High"
        else:
            return "Low"
    
    def _calculate_overall_risk_level(self, vulnerabilities):
        """Calculate overall risk level based on all vulnerabilities found"""
        if not vulnerabilities:
            return "Info"
        
        risk_levels = [vuln.get('risk_level', 'Low') for vuln in vulnerabilities]
        
        if 'High' in risk_levels:
            return 'High'
        elif 'Medium' in risk_levels:
            return 'Medium'
        elif 'Low' in risk_levels:
            return 'Low'
        else:
            return 'Info'
    
    def _format_vulnerability_summary(self, vulnerabilities):
        """Format vulnerability summary for display"""
        if not vulnerabilities:
            return "No vulnerabilities detected"
        
        summary_parts = []
        for vuln in vulnerabilities:
            service = vuln.get('service', 'Unknown')
            port = vuln.get('port', 'Unknown')
            summary_parts.append(f"{service} (Port {port})")
        
        return f"{len(vulnerabilities)} vulnerable services: {', '.join(summary_parts)}"
    
    def get_vulnerability_database(self):
        """Get the vulnerability database for external use"""
        return self.vulnerability_db
    
    def get_service_name(self, port):
        """
        Get service name for a given port
        
        Args:
            port (int): Port number
            
        Returns:
            str: Service name
        """
        if port in self.vulnerability_db:
            return self.vulnerability_db[port]["service"]
        return "Unknown"
    
    def get_critical_vulnerabilities(self, port):
        """
        Get critical vulnerabilities for a service
        
        Args:
            port (int): Port number
            
        Returns:
            list: List of critical vulnerabilities
        """
        if port not in self.vulnerability_db:
            return []
        
        vulnerabilities = self.vulnerability_db[port]["vulnerabilities"]
        
        # Filter for critical vulnerabilities (containing specific keywords)
        critical_keywords = [
            "CVE", "exploit", "buffer overflow", "injection", 
            "bypass", "escalation", "anonymous", "plaintext"
        ]
        
        critical_vulns = []
        for vuln in vulnerabilities:
            if any(keyword.lower() in vuln.lower() for keyword in critical_keywords):
                critical_vulns.append(vuln)
        
        return critical_vulns if critical_vulns else vulnerabilities[:2]  # Return first 2 if no critical found
    
    def scan_host_vulnerabilities(self, host: str, open_ports: List[int], 
                                service_info: Dict) -> Dict:
        """
        Perform comprehensive vulnerability scan on a host with CVE scoring
        
        Args:
            host: Target host IP
            open_ports: List of open ports
            service_info: Service information from port scan
            
        Returns:
            Dictionary containing enhanced vulnerability assessment
        """
        vulnerabilities = {
            'host': host,
            'scan_time': datetime.now().isoformat(),
            'risk_level': 'Low',
            'risk_score': 0,
            'vulnerabilities': [],
            'recommendations': [],
            'compliance_issues': []
        }
        
        # Scan each open port for vulnerabilities
        for port in open_ports:
            # Handle both dict and string service_info formats
            if isinstance(service_info, dict):
                service = service_info.get(port, {}).get('service', 'unknown') if isinstance(service_info.get(port, {}), dict) else str(service_info.get(port, 'unknown'))
                version = service_info.get(port, {}).get('version', '') if isinstance(service_info.get(port, {}), dict) else ''
            else:
                # Fallback for when service_info is passed as services dict directly
                service_data = service_info.get(port, {}) if hasattr(service_info, 'get') else {}
                if isinstance(service_data, dict):
                    service = service_data.get('service', 'unknown')
                    version = service_data.get('version', '')
                else:
                    service = str(service_data) if service_data else 'unknown'
                    version = ''
            
            # Enhanced port vulnerability scanning
            port_vulns = self._scan_port_vulnerabilities_enhanced(host, port, service, version)
            vulnerabilities['vulnerabilities'].extend(port_vulns)
            
            # Legacy vulnerability check for compatibility
            legacy_vulns = self._get_port_vulnerabilities(port)
            if legacy_vulns:
                for vuln in legacy_vulns.get('vulnerabilities', []):
                    vulnerabilities['vulnerabilities'].append({
                        'type': 'Service Vulnerability',
                        'severity': 'Medium',
                        'port': port,
                        'service': legacy_vulns.get('service', 'unknown'),
                        'description': vuln,
                        'cvss_score': 5.0,
                        'remediation': 'Review service configuration and apply security patches'
                    })
        
        # Perform SSL/TLS analysis for HTTPS services
        https_ports = [p for p in open_ports if p in [443, 8443] or 
                      service_info.get(p, {}).get('service') == 'https']
        for port in https_ports:
            ssl_vulns = self._scan_ssl_vulnerabilities(host, port)
            vulnerabilities['vulnerabilities'].extend(ssl_vulns)
        
        # Check for common misconfigurations
        config_issues = self._check_misconfigurations(host, open_ports, service_info)
        vulnerabilities['vulnerabilities'].extend(config_issues)
        
        # Calculate overall risk score and level
        vulnerabilities['risk_score'] = self._calculate_risk_score(vulnerabilities['vulnerabilities'])
        vulnerabilities['risk_level'] = self._determine_risk_level(vulnerabilities['risk_score'])
        
        # Generate recommendations
        vulnerabilities['recommendations'] = self._generate_recommendations(vulnerabilities['vulnerabilities'])
        
        # Check compliance issues
        vulnerabilities['compliance_issues'] = self._check_compliance_issues(vulnerabilities['vulnerabilities'])
        
        return vulnerabilities
    
    def _get_port_vulnerabilities(self, port):
        """Get vulnerability information for a specific port (legacy method)"""
        return self.vulnerability_db.get(port, {
            "service": "Unknown",
            "vulnerabilities": ["No specific vulnerabilities identified"],
            "attack_vectors": ["General network attacks"]
        })
    
    def _scan_port_vulnerabilities_enhanced(self, host: str, port: int, service: str, version: str) -> List[Dict]:
        """Enhanced port vulnerability scanning with CVE integration"""
        vulnerabilities = []
        
        if service in self.service_vulnerabilities:
            service_vulns = self.service_vulnerabilities[service]
            
            # Check for weak versions
            if 'weak_versions' in service_vulns:
                for weak_version in service_vulns['weak_versions']:
                    if weak_version in version:
                        vulnerabilities.append({
                            'type': 'Outdated Software',
                            'severity': 'High',
                            'port': port,
                            'service': service,
                            'description': f'Outdated {service} version detected: {version}',
                            'cve_ids': service_vulns.get('common_vulns', []),
                            'cvss_score': 7.5,
                            'remediation': f'Update {service} to the latest version'
                        })
            
            # Service-specific checks
            if service == 'ftp' and service_vulns.get('anonymous_login'):
                if self._check_ftp_anonymous(host, port):
                    vulnerabilities.append({
                        'type': 'Anonymous Access',
                        'severity': 'Medium',
                        'port': port,
                        'service': service,
                        'description': 'FTP allows anonymous login',
                        'cvss_score': 5.0,
                        'remediation': 'Disable anonymous FTP access'
                    })
            
            elif service == 'telnet':
                vulnerabilities.append({
                    'type': 'Unencrypted Protocol',
                    'severity': 'High',
                    'port': port,
                    'service': service,
                    'description': 'Telnet transmits data in plaintext',
                    'cvss_score': 7.5,
                    'remediation': 'Replace Telnet with SSH'
                })
            
            elif service in ['http', 'https']:
                http_vulns = self._scan_http_vulnerabilities(host, port, service == 'https')
                vulnerabilities.extend(http_vulns)
        
        return vulnerabilities
    
    def _scan_ssl_vulnerabilities(self, host: str, port: int) -> List[Dict]:
        """Scan SSL/TLS configuration for vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Create SSL context
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            # Connect and get SSL info
            with socket.create_connection((host, port), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=host) as ssock:
                    cert = ssock.getpeercert()
                    cipher = ssock.cipher()
                    
                    # Check certificate validity
                    if cert:
                        not_after = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                        if not_after < datetime.now():
                            vulnerabilities.append({
                                'type': 'Expired Certificate',
                                'severity': 'High',
                                'port': port,
                                'service': 'https',
                                'description': 'SSL certificate has expired',
                                'cvss_score': 7.5,
                                'remediation': 'Renew SSL certificate'
                            })
                    
                    # Check cipher strength
                    if cipher and len(cipher) >= 3:
                        cipher_name = cipher[0]
                        for weak_cipher in self.service_vulnerabilities['https']['weak_ciphers']:
                            if weak_cipher in cipher_name:
                                vulnerabilities.append({
                                    'type': 'Weak Cipher',
                                    'severity': 'Medium',
                                    'port': port,
                                    'service': 'https',
                                    'description': f'Weak cipher in use: {cipher_name}',
                                    'cvss_score': 5.0,
                                    'remediation': 'Configure strong cipher suites'
                                })
                                break
        
        except Exception as e:
            # SSL connection failed - might indicate SSL issues
            vulnerabilities.append({
                'type': 'SSL Configuration Issue',
                'severity': 'Medium',
                'port': port,
                'service': 'https',
                'description': f'SSL connection failed: {str(e)}',
                'cvss_score': 4.0,
                'remediation': 'Check SSL configuration'
            })
        
        return vulnerabilities
    
    def _scan_http_vulnerabilities(self, host: str, port: int, is_https: bool) -> List[Dict]:
        """Scan HTTP/HTTPS services for vulnerabilities"""
        vulnerabilities = []
        protocol = 'https' if is_https else 'http'
        
        if not requests:
            return vulnerabilities  # Skip if requests module not available
        
        try:
            url = f"{protocol}://{host}:{port}"
            response = requests.get(url, timeout=10, verify=False)
            
            # Check security headers
            security_headers = {
                'X-Frame-Options': 'Clickjacking protection missing',
                'X-Content-Type-Options': 'MIME type sniffing protection missing',
                'X-XSS-Protection': 'XSS protection missing',
                'Strict-Transport-Security': 'HSTS header missing',
                'Content-Security-Policy': 'CSP header missing'
            }
            
            for header, description in security_headers.items():
                if header not in response.headers:
                    vulnerabilities.append({
                        'type': 'Missing Security Header',
                        'severity': 'Medium',
                        'port': port,
                        'service': protocol,
                        'description': description,
                        'cvss_score': 4.0,
                        'remediation': f'Add {header} header'
                    })
            
            # Check for information disclosure
            server_header = response.headers.get('Server', '')
            if server_header:
                vulnerabilities.append({
                    'type': 'Information Disclosure',
                    'severity': 'Low',
                    'port': port,
                    'service': protocol,
                    'description': f'Server header reveals: {server_header}',
                    'cvss_score': 2.0,
                    'remediation': 'Hide or modify server header'
                })
        
        except Exception:
            pass  # Connection failed, skip HTTP checks
        
        return vulnerabilities
    
    def _check_ftp_anonymous(self, host: str, port: int) -> bool:
        """Check if FTP allows anonymous login"""
        try:
            import ftplib
            ftp = ftplib.FTP()
            ftp.connect(host, port, timeout=10)
            ftp.login('anonymous', 'anonymous@example.com')
            ftp.quit()
            return True
        except:
            return False
    
    def _check_misconfigurations(self, host: str, open_ports: List[int], 
                               service_info: Dict) -> List[Dict]:
        """Check for common misconfigurations"""
        vulnerabilities = []
        
        # Check for dangerous port combinations
        if 23 in open_ports:  # Telnet
            vulnerabilities.append({
                'type': 'Insecure Service',
                'severity': 'High',
                'port': 23,
                'service': 'telnet',
                'description': 'Telnet service is inherently insecure',
                'cvss_score': 7.5,
                'remediation': 'Disable Telnet and use SSH instead'
            })
        
        # Check for too many open ports (potential attack surface)
        if len(open_ports) > 20:
            vulnerabilities.append({
                'type': 'Large Attack Surface',
                'severity': 'Medium',
                'port': 0,
                'service': 'general',
                'description': f'Host has {len(open_ports)} open ports',
                'cvss_score': 5.0,
                'remediation': 'Close unnecessary ports and services'
            })
        
        return vulnerabilities
    
    def _calculate_risk_score(self, vulnerabilities: List[Dict]) -> float:
        """Calculate overall risk score based on vulnerabilities"""
        if not vulnerabilities:
            return 0.0
        
        total_score = sum(vuln.get('cvss_score', 0) for vuln in vulnerabilities)
        return min(total_score / len(vulnerabilities), 10.0)
    
    def _determine_risk_level(self, risk_score: float) -> str:
        """Determine risk level based on score"""
        if risk_score >= 7.0:
            return 'Critical'
        elif risk_score >= 5.0:
            return 'High'
        elif risk_score >= 3.0:
            return 'Medium'
        else:
            return 'Low'
    
    def _generate_recommendations(self, vulnerabilities: List[Dict]) -> List[str]:
        """Generate security recommendations"""
        recommendations = []
        
        # Group vulnerabilities by type
        vuln_types = {}
        for vuln in vulnerabilities:
            vuln_type = vuln.get('type', 'Unknown')
            if vuln_type not in vuln_types:
                vuln_types[vuln_type] = []
            vuln_types[vuln_type].append(vuln)
        
        # Generate recommendations based on vulnerability types
        if 'Outdated Software' in vuln_types:
            recommendations.append('Update all software to the latest versions')
        
        if 'Missing Security Header' in vuln_types:
            recommendations.append('Implement proper HTTP security headers')
        
        if 'Weak Cipher' in vuln_types:
            recommendations.append('Configure strong SSL/TLS cipher suites')
        
        if 'Insecure Service' in vuln_types:
            recommendations.append('Replace insecure services with secure alternatives')
        
        return recommendations
    
    def _check_compliance_issues(self, vulnerabilities: List[Dict]) -> List[Dict]:
        """Check for compliance framework violations"""
        compliance_issues = []
        
        # PCI DSS compliance checks
        pci_violations = []
        for vuln in vulnerabilities:
            if vuln.get('type') == 'Weak Cipher':
                pci_violations.append('PCI DSS 4.1: Strong cryptography required')
            elif vuln.get('service') == 'telnet':
                pci_violations.append('PCI DSS 2.3: Encrypt all non-console administrative access')
        
        if pci_violations:
            compliance_issues.append({
                'framework': 'PCI DSS',
                'violations': pci_violations
            })
        
        # NIST Cybersecurity Framework checks
        nist_violations = []
        for vuln in vulnerabilities:
            if vuln.get('type') == 'Outdated Software':
                nist_violations.append('PR.IP-12: Vulnerability management plan')
            elif vuln.get('type') == 'Missing Security Header':
                nist_violations.append('PR.DS-1: Data-in-transit protection')
        
        if nist_violations:
            compliance_issues.append({
                'framework': 'NIST CSF',
                'violations': nist_violations
            })
        
        return compliance_issues

    def generate_vulnerability_report(self, scan_results: Dict) -> str:
        """Generate a comprehensive vulnerability report"""
        report = []
        report.append("VULNERABILITY ASSESSMENT REPORT")
        report.append("=" * 50)
        report.append(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        report.append("")
        
        # Executive Summary
        total_hosts = len(scan_results)
        critical_hosts = sum(1 for data in scan_results.values() 
                           if data.get('vulnerabilities', {}).get('risk_level') == 'Critical')
        high_risk_hosts = sum(1 for data in scan_results.values() 
                            if data.get('vulnerabilities', {}).get('risk_level') == 'High')
        
        report.append("EXECUTIVE SUMMARY")
        report.append("-" * 20)
        report.append(f"Total Hosts Scanned: {total_hosts}")
        report.append(f"Critical Risk Hosts: {critical_hosts}")
        report.append(f"High Risk Hosts: {high_risk_hosts}")
        report.append("")
        
        # Detailed findings
        report.append("DETAILED FINDINGS")
        report.append("-" * 20)
        
        for host, data in scan_results.items():
            vuln_data = data.get('vulnerabilities', {})
            if not vuln_data.get('vulnerabilities'):
                continue
                
            report.append(f"\nHost: {host}")
            report.append(f"Risk Level: {vuln_data.get('risk_level', 'Unknown')}")
            report.append(f"Risk Score: {vuln_data.get('risk_score', 0):.1f}/10.0")
            
            for vuln in vuln_data.get('vulnerabilities', []):
                report.append(f"  • {vuln.get('type', 'Unknown')} ({vuln.get('severity', 'Unknown')})")
                report.append(f"    Port: {vuln.get('port', 'N/A')}")
                report.append(f"    Description: {vuln.get('description', 'N/A')}")
                report.append(f"    CVSS Score: {vuln.get('cvss_score', 0)}")
                report.append(f"    Remediation: {vuln.get('remediation', 'N/A')}")
                report.append("")
        
        return "\n".join(report)

    def format_vulnerability_summary(self, port, service_info=""):
        """
        Format a concise vulnerability summary for reporting
        
        Args:
            port (int): Port number
            service_info (str): Service information
            
        Returns:
            str: Formatted vulnerability summary
        """
        assessment = self.assess_vulnerabilities(port, service_info)
        service_name = assessment["service"]
        risk_level = assessment["risk_level"]
        
        # Get the most critical vulnerability
        critical_vulns = self.get_critical_vulnerabilities(port)
        main_vuln = critical_vulns[0] if critical_vulns else "Standard service risks"
        
        # Shorten the vulnerability description
        if len(main_vuln) > 30:
            main_vuln = main_vuln[:27] + "..."
        
        # Format based on risk level
        if risk_level == "High":
            return f"{service_name}: {main_vuln} (HIGH RISK)"
        elif risk_level == "Medium":
            return f"{service_name}: {main_vuln} (MEDIUM)"
        else:
            return f"{service_name}: {service_info}" if service_info else f"{service_name}: Standard risks"